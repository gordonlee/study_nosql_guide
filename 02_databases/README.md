# Quick Link for this page
* [키-값 데이터베이스](https://github.com/gordonlee/study_nosql_guide/tree/master/02_databases#8장-키-값-데이터베이스)
* [문서 데이터베이스]()
* [컬럼 패밀리 저장소]()
* [그래프 데이터 베이스]()
<br>
<br>

# 들어가며

앞으로 나오는 네 가지의 대표적인 DB 를 비교해본다. 
비교 할 때, 아래의 요소들로 비교해서 생각해본다.

* 일관성
* 트랜잭션
* 가용성
* 조회
* 확장성
<br>
<br>

# 8장. 키-값 데이터베이스

## 1. 정의
	
key-value 형태로 저장되며, 단일 value에 접근하려면 key를 알고 있어야 한다. 

DB는 value에 대해 알고 있는 정보가 없으며, 그저 유저(client)에게 값을 던져줄 뿐이다.

![key_value_structure](/02_databases/img/key-value_structure.png)

## 2. 특징

* 일관성
	* 분산이 가능하여 후처리가 가능하다. 이때 옵션으로는 최신 쓰기를 반영하고 예전 쓰기는 덮어쓸 수도 있고, 동시성 문제가 생기는 두 개 이상의 업데이트를 클라이언트에게 리턴해서 리졸브를 요청할 수도 있다. 혹은, 쓰기 노드를 모두 성공적으로 써진 다음에 리턴할 수도 있다.
* 트랜잭션
	* 일반적으로 쓰기 보장이 없다. 정족수 개념을 사용하여 후 업데이트 전략을 취하는 것이 보통이다.
* 가용성
	* 각 데이터베이스마다 지원하는 기능이 다르겠지만, 보통 샤딩은 지원하는 것 같고, 복제에 대한 얘기는 많이 없다.
* 조회
	* key로 조회가 가능하며, 기본 컨셉은 이게 전부다. 리악의 경우 별도의 라이브러리를 이용하여 인덱싱을 할 수는 있다. 
* 확장성
	* 샤딩으로 확장이 가능하며, 쓰기시 필수 응답 노드 갯수를 지정해서 정족수 개념을 적용할 수 있다.

## 3. 사용처

* 적절한 사용처
	* key가 항상 유니크해야하고 DB로 부터 이 키를 알아올 수가 없기 때문에, 어플리케이션 레벨에서 key를 바로 만들 수 있어야 한다. 이런 고정 키가 정해진 부분에 사용하면 부하없이 벨류를 잘 찾아올 수 있다. 
		* 예시: 세션 정보 저장용, 사용자 프로파일/설정 정보, 장바구니 데이터 등 

* 부적절한 사용처 
	* 데이터 간의 관계가 형성 되어 있는 경우나 다중 연산 트랜잭션이 필요한 경우는 피해야 한다. 혹은 key가 아닌 value안에 있는 내용으로 조회를 해야하거나, 집합 연산을 하는 경우는 해당 데이터베이스를 피하는 것이 좋다.

<br>
<br>

# 9장. 문서 데이터베이스

## 1. 정의 

문서는 맵이나 컬렉션, 스칼라 값을 포함할 수 있는 자체 기술적(self-describing), 계층적 트리 데이터 구조다.

![key-value_vs_document_db](/02_databases/img/key-value_vs_document_db.png)

## 2. 특징

* 일관성
	* replica set 을 사용한다.
		* 쓰기가 모든 슬레이브에 복제될 때까지 기다릴 수 있다.
		* 주어진 수의 슬레이브에 복제될 때 까지만 기다릴 수 있다.
	* 몽고디비에선 SlaveOK(); 를 이용하여 슬레이브에서 읽기를 허용할 수 있다.

* 트랜잭션
	* 기본적으로 원자적 트랜잭션이다. writeConcern으로 보장을 할지 안할지 설정이 가능하다.<- 결국 정족수 개념으로 몇 개의 쓰기노드으로부터 응답을 받을 것인가를 설정

* 가용성
	* 마스터-슬레이브를 내부적으로 제어하고 있으며 어플리케이션단에서 제어할 필요는 없다.
		> 복제본 집합: 노드 중에서 주 노드를 설정하고, 마스터(주) 노드에 장애가 생기면 남은 슬레이브에서 하나를 마스터(주) 노드로 설정하는 것.
		
		![replication](/02_databases/img/replication.png)
		
* 조회
	* 일반적인 쿼리나 구체화 뷰를 사용할 수 있다.
* 확장성
	* 런타임에 새 노드를 추가할 수 있으나, 런타임에 데이터를 복제하거나 샤딩 벨런싱을 하기 때문에, 100%의 동일한 응답성을 주진 못한다.

## 3. 사용처

확장성도 괜찮은 편이고, 데이터 수집 단계에서 간단한 구체화 뷰를 이용하여 캐싱할 수 있기 때문에 관련 기술이 필요한 곳에 적용이 유리하다.

* 적절한 사용처
	* 이벤트 로깅, 콘텐츠 관리 시스템/블로깅 플랫폼, 웹 분석/실시간 분석, 전자 상거래 애플리케이션

* 부적절한 사용처
	* 여러 연산에 걸친 복잡한 트랜잭션이나 변화하는 집합 구조에 대한 쿼리를 하는 경우는 피하는 것이 좋다.

<br>
<br>


# 10장. 컬럼 패밀리 저장소

## 1. 정의

대표적인 DB 카산드라인데, 이는 빠르고 쓰기 확장성이 뛰어나다. master Node가 없어서 어느 노드던 읽기와 쓰기가 가능하다.

![column_family](/02_databases/img/column_family.png)

## 2. 특징
* 칼럼은 이름-값의 쌍으로 되어있다.
* 각 키-값 쌍이 한 컬럼이며 항상 타임스탬프와 함께 저장된다.
	> 칼럼 패밀리: 비슷한 행의 모임

	> 표준 칼럼 패밀리

	> 슈퍼 칼럼: 칼럼이 칼럼의 맵으로 구성된 경우

	> 슈퍼 칼럼 패밀리: 칼럼 패밀리에 슈퍼 칼럼이 있는 경우

* 일관성
	
	![memtable_sstable](/02_databases/img/memtable_sstable.png)

	* 쓰기/읽기 시 일관성 설정이 가능 (p2p model)

	* 힌티드 핸드오프가 가능

	> 읽기 보정(read repaire): 첫번째 복제본을 리턴한다. 그 데이터가 낡은 경우도 마찬가지다. 해당 데이터가 낡은 경우, 이후 읽기부터는 최신 데이터를 읽을 것이다. // fixme:

	> 힌티드 핸드오프(hinted handoff): 노드 하나가 다운되면, 해당 노드에 저장되어 있던 데이터의 관할권이 다른 노드로 넘어갔다가 온라인 상태로 돌아오면 변경사항이 원래 노드로 돌아가는 것

* 트랜잭션
	* 전통적인 방법은 없음. 쓰기는 행 단위로 원자적이다. 위 그림 처럼 쓰기 시, 커밋로그도 함께 날려서 문제가 생기면 보정하는 식으로 처리한다.

	![cassandra](/02_databases/img/cassandra.png)

* 가용성
	* 분할 기능으로 정족수 수치를 정해서 처리

* 조회
	* 기본 쿼리: get, set, del 명령으로 제어
	* 고급쿼리와 인덱싱: 인덱스 생성 가능(bitmap index로 구현되어 있음)
	* 카산드라 쿼리 언어( CQL ): 조인이나 서브쿼리 불가능

* 확장성
	* 단일 마스터 노드가 없어서 추가가 용이함


## 3. 사용처

* 적절한 사용처 
	* 이벤트 로깅, 콘텐츠 관리 시스템/블로깅 플랫폼, 카운터, 기간만료(카산드라 내부에 ttl에 의한 만료 기능을 제공)

* 부적절한 사용처 
	* 데이터 집계 시, client에서 모든 내용을 쿼리해서 처리해야한다. 스키마 변경 비용보다 쿼리 변경 비용이 더 크다.

<br>
<br>



# 11장. 그래프 데이터 베이스

## 1. 정의

* 노드는 name 속성을 가진 엔티티, 간선은 관계에 대한 정보를 가진 엔티티
* 쿼리는 그래프 순회를 이용한다.
* 그래프 DB에선 조인 또는 관계를 순회하는 것이 매우 빠르다. 쿼리시 중간에 계산해서 결과를 내는 것이 아니라, 실제로 그렇게 저장되어 있기 때문이다.

## 2. 특징

* 일관성
	* 보통 노드 분산을 지원하지 않는다. 단일 서버에서는 ACID를 완벽하게 지원한다.
	* 트랜잭션도 사용할 수 있다.

* 트랜잭션
	* 코딩 시 연산을 트랜잭션으로 묶지 않으면 exception이 발생한다. 읽기는 트랜잭션이 없어도 가능.

* 가용성
	* 아파치 주키퍼를 이용하여 마스터-슬레이브 모델 서버를 처리할 수 있다. 마스터가 다운되면 슬레이브 중 1개를 마스터로 설정한다.

* 쿼리
	* DSL(Domain-Specific Language)를 이용한다. 예로 그렘린, 사이퍼등의 라이브러리들이 있다.
	* 관계나 속성으로 인덱싱이 가능하다. 

* 확장성
	* 샤딩이 어려움.
	* 향상전략: 스펙업, 마스터-슬레이브 모델, 서버군으로 분리 등의 방편이 있다.

## 3. 사용처
* 적절한 사용처
	* 연결된 데이터, 라이팅/디스패치/위치기반 서비스, 추천엔진

* 부적절한 사용처 
	* 엔티티 전체 접근, 분석 시스템 등...
