# Quick Link for this page
* [왜 NoSQL인가](https://github.com/gordonlee/study_nosql_guide/tree/master/01_concept#1장-왜-nosql-인가)
* [집합적 데이터 모델](https://github.com/gordonlee/study_nosql_guide/tree/master/01_concept#2장-집합적-데이터-모델)
* [데이터 모델 상세](https://github.com/gordonlee/study_nosql_guide/tree/master/01_concept#3장-데이터-모델-상세)
* [분산 모델](https://github.com/gordonlee/study_nosql_guide/tree/master/01_concept#4장-분산-모델-수평-확장-스케일-아웃)
* [일관성](https://github.com/gordonlee/study_nosql_guide/tree/master/01_concept#5장-일관성)
* [버전 스탬프](https://github.com/gordonlee/study_nosql_guide/tree/master/01_concept#6장-버전-스탬프)
* [맵-리듀스](https://github.com/gordonlee/study_nosql_guide/tree/master/01_concept#7장-맵-리듀스-scatter-gather의-한-형태)
<br>
<br>

# 1장. 왜 NoSQL 인가?
간단한 히스토리에 관한 내용이므로 쉽게 읽고 책에서 기술한 요약본만 기록해둔다. 

* 관계형 데이터베이스는 20년 이상 성공적인 기술이고, 지속성/동시성 제어/통합 메커니즘을 제공한다.
* 관계형 데이터베이스에서 객체-관계 불일치로 불만이 많다.
* 저장소 변화의 중요 요인은 클러스터에 있다. 
	
#### NoSQL의 공통 특징
* 관계형 모델을 사용하지 않는다.
* 클러스터에서 잘 동작한다.
* 오픈소스다.
* 21세기 web 환경을 위해 구축되었다. 
* 스키마가 없다.
* *__그 결과로 다중 저장소 지속성을 특징으로 꼽을 수 있다.__* 
<br>
<br>

# 2장. 집합적 데이터 모델

* 집합(aggregate): 다루고 싶은 객체의 무리
    * RDB에선 정규화하여 여러 테이블로 나눠서 사용하지만, NoSQL은 데이터 단위를 집합으로 묶어서 처리한다. 
    * 집합 구조는 단일 집합을 조회하긴 용이하지만, 지난 몇 달간 제품 판매 상황을 보려면 모든 집합을 서칭해야 한다. 
    * 집합-지향은 클러스터에서 장점을 가진다.

> 데이터 모델: 어플리케이션에서 특정 데이터의 모델 (aka 메타모델)

> ERD (Entity-Relationship Diagram): 개체-관계 다이어그램

> ACID 트랜잭션 (Atomic, Consistent, Isolated, Durable): 원자적이고, 일관성을 유지하고, 격리되어 있으며, 영속적인 것을 보장하는 트랜잭션.

* NoSQL은 보통 여러 집합을 포괄하는 트랜잭션이 없다. 대신 집합 단위는 원자적으로 동작한다.

* 키-값 모델:
	* 집합 구조가 불투명하다
	* 내용이 바이너리처럼 취급된다. -> 무엇이든지 저장할 수 있다. 
	* key로만 접근이 가능하다

* 문서 데이터베이스 모델: 
	* 집합의 구조를 볼 수 있다. 
	* 집합에 허용되는 구조가 제한적이다. 
	* 집합 필드를 이용해 질의를 할 수 있다. 
	* 인덱스를 만들 수도 있다. 

* 칼럼 패밀리 저장소
	* 특정 컬럼의 정보를 대량으로 읽을 때 유리하다. 
	* 물리적으로 컬럼 패밀리 단위로 모아둔다. (접근성 향상)

* 요약
	* 집합-지향 데이터베이스는 모든 데이터 상호작용이 같은 집합으로 이루어 질 때 가장 좋다. 상호작용에 여러가지 다른 형태로 조직된 데이터가 사용된다면 집합-무지 데이터베이스가 낫다. 
<br>
<br>

# 3장. 데이터 모델 상세

* 관계
	* NoSQL에서 키-값, 문서, 컬럼 형태의 모델에선 다른 집합간의 관계를 사용자(어플리케이션)에서 직접 설정해야 한다. DB는 관계에 관한 정보를 알 수 없다. 

* 그래프 데이터베이스
	* 그래프 데이터베이스는 상호 연결이 복잡하고, 레코드 크기가 작은 모델을 가진다. 
	* 데이터 구조가 노드와 간선으로 이루어져있다. 쿼리 연산으로 네트워크를 검색할 수 있다. 
	* 클러스터에서 처리하기 어렵다. 일관성을 위한 노드+간선의 트랜잭션도 필요하다. 

* 스키마 없는 데이터베이스
	* 스키마 변경에 능숙하다. 
	* 균일하지 않은 데이터를 처리하는 것도 쉬워진다. 그러나, 암묵적 스키마가 존재한다. (읽기/쓰기 시, 어떤 스키마가 있는지 알아야함)
	* 단점
		* 어플리케이션에서 코드를 찾아야 스키마를 알 수 있다. 
		* 스키마 정보를 활용할 수 없다. 
		* 데이터 유요성등의 작업도 할 수 없다.

* 구체화 뷰 (materialized view) --> 맵-리듀스
	* 계산 결과를 미리 만들어 디스크에 캐시해두는 것을 말한다. 
	* 방법
		* 기본 데이터가 바뀔 때 갱신하는 방법
		* 주기적으로 배치를 실행하여 갱신하는 방법

* 데이터 접근을 위한 모델링 // 데이터를 어떻게 읽을 것인가??
	* 집합을 기반으로 하는 데이터베이스에서 빠르게 읽는 노하우는 **역정규화**를 시키는 것이다. 한 집합에 한 번에 읽을 데이터를 최대한 담는 것.
	* 그래프 데이터베이스는 관계(간선)의 속성으로 쿼리를 내릴 수 있다. 
		* 만약 '리펙터링 데이터베이스'란 상품을 구매한 모든 고객을 찾으려면, 상품 노드를 찾은 다음 구매(PURCHASE) 간선을 따라가면 된다. 
<br>
<br>

# 4장. 분산 모델 (수평 확장, 스케일-아웃)

* 분산 방법
    * 샤딩 (sharding): 물리적 데이터를 수평적으로 확장하는 방법
		* key는 접근성에 있다. 
			* 함께 사용하는 데이터를 최대한 모아둔다. 
				* 한 사용자가 필요로하는 데이터의 로컬리티 -> 집합으로 해결
				* 물리적 거리를 고려한 로컬리티 -> 물리적 접근 경로 최소화
				* 부하를 균등하게 배분

		* 샤딩만 단독으로 사용하면 복원력(resilience)에 문제가 생긴다. 
			* 10개로 샤딩한다고 하면, 평균적으로 1개에 10%의 데이터가 나뉘어 담긴다. 이 때 1개가 장애 상황에 빠지면 10%의 데이터는 사용하지 못하게 된다.

		* 샤딩을 적용할 예정이라면 가급적 개발 단계에서 샤딩을 설정하는 것이 좋다. 
			* 왜? 기존에 단일 서버에 적재된 데이터를 갖고 있는 상태에서 샤딩 설정을 하면 데이터를 샤딩 프로세스로 퍼날라야 하기 때문이다.

	* 복제 (replication) 
		* 마스터-슬레이브 모델 (master-slave model)
			* 쓰기는 마스터에, 읽기는 슬레이브에서 하는 모델
			* 읽기 작업이 많은 상황에서 부하를 슬레이브에 주어 큰 효과를 볼 수 있다. 
			* 읽기 복원력 (마스터에서 읽기를 실패하면, 슬레이브에서 읽으면 된다.)이 좋다. 
			* 마스터가 불가 상태면, 마스터 역할을 특정 슬레이브에서 수행 할 수 있다. 
			* 단점으로는 비일관성 문제가 발생한다. (유저의 쓰기 -> 마스터 적용 -> 슬레이브 전파 간 일관성 문제가 생김)
		* 피어-투-피어 모델 (peer-to-peer model)
			* 마스터를 두지 않는 구조. SPOF가 없어지지만 복잡도가 올라간다. (특히 일관성 복잡도가 상승)
			* 일관성
				* 쓰기 일관성의 경우,
					* 매번 쓰기 시, 항상 복제본과 조율
					* 우선 쓰고, 나중에 병합하는 방법
				* 일관성~가용성 사이에서 조율이 필요하다. 

* 보통의 경우는 샤딩과 복제를 결합하여 사용한다. 
	* 샤딩 + 마스터-슬레이브 모델
	* 샤딩 + P2P 모델
<br>
<br>

# 5장. 일관성

> 용어> 쓰기 충돌 (write-write conflict): A, B가 동시에 동일한 데이터를 수정하려고 할 때
> 용어> 업데이트 손실(lost update): 위와 같은 쓰기 충돌이 일어날 경우, 업데이트가 손실되는 문제

* 업데이트 일관성
	* DB가 요청을 직렬화하여 처리하면 -> A가 쓴 값 -> B가 쓴 값 // 결론적으로 A가 쓴 값은 무시됨
	* 업데이트 손실의 처리 방법
		* 비관적 처리: 충돌 발생을 방지하는 개념. > 쓰기 시, 쓰기 잠금(write lock)을 걸어서 처리한다. 아무래도 성능이 느려짐
		* 낙관적 처리: 충돌을 발생시키고, 이를 탐지해 적절한 조치를 하는 방향 [ 조건적 업데이트 (Conditional Update) ] > 먼저 온 A를 처리하고, B를 실패시킨다.
	* 위와 같은 문제를 피하기 위해, 분산 구조에서 대부분 쓰기를 단일 노드에서 처리한다. 

> 비일관적 읽기 (inconsistent read) 혹은 읽기-쓰기 충돌 (read-write conflict) : 위와 같은 시나리오에서 B는 잘못된 데이터를 읽었다.

> 논리적 일관성: read-write conflict를 해결하는 것.

> 비일관성 윈도 (inconsistency window): 비일관성이 존재하는 시간의 길이 (길이가 길면 비일관성이 된 상태가 길어진다.)

> 용어> 세션 일관성: 내가 반영한 값이 내가 보기에 제대로 읽히는 것.

* 읽기 일관성
	* 시나리오: A가 1 데이터를 쓴다 -> B가 1 + 2 데이터를 읽는다 -> A가 나머지 2 데이터를 쓴다. 
	* 논리적 일관성 보장
		* RDB와 그래프 데이터베이스에선 트랜잭션 사용. (ACID)
		* 나머지 NoSQL에선 집합 인스턴스에 대해 원자성이 보장되므로 최대한 동일 집합에서 처리
	* 복제 일관성 ( 또는 결과적 일관성(eventual consistency) )
		* P2P 모델에서 A와 B가 동시에 서로 다른 db node에 예약을 수행하는 경우
		* 독립적 인스턴스에선 세션 일관성만 보장되어도 큰 문제가 없다.
			* 세션 일관성을 보장하기 위한 방법 
				* 스티키 세션 (sticky session)
				* 세션의 쓰기가 완료될 때까지 읽기도 동일 DB에서 하도록 강제 (마스터 db로 잠깐 잡아 둔다)

> CAP ( Consistency, Availability, Partition tolerance ): 일관성, 가용성, 분단 허용성

* 일관성 완화: 결국 성능~일관성 보장 간의 tradeoff이다.

* 지속성 완화
	* 메모리 케시처럼, 매번 저장하지 않고, 캐시했다가 한번에(주기적으로) 저장해준다. 저장하기 전에 장애 상황이 발생하면 데이터는 날아갈 수 있지만, 속도가 빠르다. 

> 복제 지속성 (replication durability) 실패: 마스터에서 슬레이브로 데이터 1, 2, 3을 전파할 때, 일부가 실패하는 현상 (예로 2번 데이터가 실패)

* 정족수
	* 쓰기 정족수(write quorum)
		* 요청에 더 많은 노드가 관여하면 비일관성을 회피할 확률이 더 높아진다. 강력한 일관성을 얻으려면 얼마나 많은 노드가 관여해야 하는가? 
			* 쓰기 충돌이 발생하면, 다수로부터 데이터를 얻을 수 있다. 
			* W > N / 2 [ W: 쓰기 노드 수, N: 복제 노드 수 ] // 복제본 수를 복제 인수 (replication factor)라고 도 한다. 
	* 읽기 정족수 (read quorum) 
		* 최신 데이터를 얻기 위해 W 노드를 모두 확인해야 한다. 
		* R + W > N [ R: 읽기 시 확인해야 하는 노드 수, W: 쓰기 시 승인해야 하는 노드 수, N: 복제 인수 ]
<br>
<br>

# 6장. 버전 스탬프

* 단일 서버 분산 모델에서 다른 분산 모델로 이전할 때 용이한 방법이다. 

* 구현 방법
	* 타임 스탬프
	* GUID 생성
	* 자원 내용(컨텐츠)으로 해시 생성
	* 마지막 업데이트의 타임스탬프 이용

* 여러 구현 방법을 서로 혼합하여 사용할 수 있다.

* 다중 노드에서의 타임 스탬프 (P2P model에서의 개념)
	* 벡터 스탬프 (vector stamp) 개념
		* A, B, C 노드가 있을 때, [ A: 94, B: 23, C: 10 ] 와 같은 형태로 각자 Count를 적어서 최신 데이터임을 판별해낸다.

> 낙관적 오프라인 잠금: 트랜잭션 커밋전에 데이터가 초기 상태와 동일한지 마지막에 한 번 더 확인하는 방법. ( 멀티 스레딩에서 CAS( Compare-and-set)과 유사)
<br>
<br>

# 7장. 맵-리듀스 (Scatter-Gather의 한 형태)
각 DB 마다 구현되어 있는 내용이 다르긴 하지만, 개념적으로 접근했을 때 아래와 같은 특징을 가진다. 

![Map Reduce Algorithm](/img/map_reduce_algorithm.png)

![Map Reduce Vitualization](/img/map_reduce_vitualization.png)

1. 생각의 출발
        
    '지난 7일간 제품별 매출 정보를 조회하려고 한다.' 
    
    -> 노드가 독립적이기 때문에 안전하게 병렬화해서 처리한다. 
    
    -> 각자 계산해서 나중에 합친다. 

2. 분할과 결합

    각 리듀스 함수는 키 하나에 대해서만 가능.

    키 별로 하나의 집합에 계산한 후 결합한다.

    결합 가능한 리듀스 함수와 불가능한 리듀스 함수:
        
        만약 '특정 제품에 대한 고유(unique) 고객수를 센다면?'-> 단순 sum으로는 불가능하기 때문에 위와 같은 기법으로는 불가능.

맵-리듀스 계산이 복잡해지면, 파이프와 필터를 이용하여 단계를 나눈다

단계가 많아지면 -> 중간 결과물을 재활용 할 수 있다.

점증적 맵-리듀스란? 입력마다 결과를 해당 건에만 계산해서 만드는 방법.

